# JavaScript 基础 

## 一、简介

JavaScript是一门运行在浏览器端的动态类型的编程语言，由两大部分组成：ECMAScript和webAPIs（DOM、BOM）。

现代JS不只可以运行在浏览器端，通过V8引擎，也可以运行在服务端（Node.js）。

JS的作用很多，最基本的作用就是实现网页交互效果，实现表单验证等。

## 二、JS书写位置

JavaScript 程序不能独立运行，它需要被嵌入 HTML 中，然后浏览器才能执行 JavaScript 代码。通过 `script` 标签将 JavaScript 代码引入到 HTML 中，有两种方式：

#### 2.1 内部方式

通过 `script` 标签包裹 JavaScript 代码

```html
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Title</title>
</head>
<body>
<!-- 
内部js写在script标签中，script标签一般会放在body结束标签的前面 
这样可以等页面元素加载完成，防止出现一些没必要的问题
-->
<script>
	console.log('嗨，欢迎学习JS!');
</script>
</body>
</html>
```

#### 2.2 外部形式

一般将 JavaScript 代码写在独立的以 .js 结尾的文件中，然后通过 `script` 标签的 `src` 属性引入

```javascript
// my.js
console.log('嗨，欢迎学习JS!');
```

```html
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Title</title>
</head>
<body>
<!-- 外部形式：通过 script 的 src 属性引入独立的 .js 文件 -->
<script src="./js/my.js">
	// 引入了外部js文件的script标签中不能再写js代码，写了也会被忽略
	// 此处的代码会被忽略掉！！！！
	alert(666);
</script>
</body>
</html>
```

#### 2.3 内联形式

内联形式的javascript用的较少，一般只会写一些简单的代码。或者在一些框架中使用。

```html
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Title</title>
</head>
<body>
<button onclick="alert('这是一个弹窗')">button</button>
</body>
</html>
```

## 三、注释和结束符

通过注释可以屏蔽代码被执行或者添加备注信息，JavaScript 支持两种形式注释语法：

#### 3.1 单行注释

使用 `// ` 注释单行代码

```js
// 这种是单行注释的语法
    // 一次只能注释一行
    // 可以重复注释
    console.log('嗨，欢迎学习JS!');
```

#### 3.2 多行注释

使用 `/* */` 注释多行代码

```js
/* 这种的是多行注释的语法 */
    /*
    	更常见的多行注释是这种写法
    	在些可以任意换行
    	多少行都可以
      */
    console.log('嗨，欢迎学习JS!');
```

**注：编辑器中单行注释的快捷键为 `ctrl + /`**

#### 3.3 结束符

在 JavaScript 中 `;` 代表一段代码的结束，多数情况下可以省略 `;` 使用回车（enter）替代。

```js
alert(1);
alert(2);
alert(1)
alert(2)
```

实际开发中有许多人主张书写 JavaScript 代码时省略结束符 `;`

但具体情况还是要看团队约定

## 四、输入和输出

输出和输入也可理解为人和计算机的交互，用户通过键盘、鼠标等向计算机输入信息，计算机处理后再展示结果给用户，这便是一次输入和输出的过程。

举例说明：如按键盘上的方向键，向上/下键可以滚动页面，按向上/下键这个动作叫作输入，页面发生了滚动了这便叫输出。

#### 4.1 输出

JavaScript 可以接收用户的输入，然后再将输入的结果输出：

`alert()`、`document.wirte()`、`console.log()`

以数字为例，向 `alert()`输入任意数字，他都会以弹窗形式展示（输出）给用户。

```javascript
// 向文档输出内容，这种方式使用很少，会破坏文档结构，一般只做测试用
	document.write('学习输入输出');
	document.write('<h1>这是一个标题</h1>');
  
  // 警告框
	alert('这是一个弹窗');
  
  // 这种方式一般用于调试程序,结果会在浏览器的控制台中打印出来
	console.log('控制台打印');
```

####  4.2 输入

向 `prompt()` 输入任意内容会以弹窗形式出现在浏览器中，一般提示用户输入一些内容。

```js
// 以弹窗形式提示用户输入姓名，注意这里的文字使用英文的引号
    prompt('请输入您的姓名:');
```

## 五、变量和常量

变量是计算机中用来存储数据的“容器”，它可以让计算机变得有记忆，通俗的理解变量就是使用【某个符号】来代表【某个具体的数值】（数据）

```javascript
// x 符号代表了 5 这个数值
  x = 5
  // y 符号代表了 6 这个数值
  y = 6
    
  //举例： 在 JavaScript 中使用变量可以将某个数据（数值）记录下来！

  // 将用户输入的内容保存在 num 这个变量（容器）中
  num = prompt('请输入一数字!')

  // 通过 num 变量（容器）将用户输入的内容输出出来
  alert(num)
  document.write(num)
```

### 5.1 声明和赋值

声明(定义)变量有两部分构成：声明关键字、变量名（标识）

关键字是 JavaScript 中内置的一些英文词汇（单词或缩写），它们代表某些特定的含义，如 `let` 的含义是声明变量的，看到 `let`  后就可想到这行代码的意思是在声明变量，如 `let age;` 

`let` 和 `var` 都是 JavaScript 中的声明变量的关键字，推荐使用 `let` 声明变量！！！

let同一作用域中不允许重名变量，同一变量不允许多次声明。

声明（定义）变量相当于创造了一个空的“容器”，通过赋值向这个容器中添加数据。

变量在声明的时候可以赋值，称为变量的初始化。

可以同时声明多个变量。

```js
// 变量的声明
	let age;
	// 变量的赋值
	age = 24;

	// 变量的使用
  age = age + 1;
	console.log(age);

	// 声明变量的同时赋值，称为变量的初始化
	let name = '苏白';
	console.log(name);
  
  // 同时声明多个变量，但不推荐这样使用
  let num = 23, sb = '苏白';
	console.log(num,sb);
```

### 5.2 关键字

JavaScript 使用专门的关键字 `let` 和 `var` 来声明（定义）变量，在使用时需要注意一些细节：

以下是使用 `let` 时的注意事项：

1. 允许声明和赋值同时进行
2. 不允许重复声明
3. 允许同时声明多个变量并赋值
4. JavaScript 中内置的一些关键字不能被当做变量名

以下是使用 `var` 时的注意事项：

2. 允许声明和赋值同时进行
2. 允许重复声明
3. 允许同时声明多个变量并赋值

大部分情况使用 `let` 和 `var` 区别不大，但是 `let` 相较 `var` 更严谨，因此推荐使用 `let`

### 5.3 变量名命名规则

关于变量的名称（标识符）有一系列的规则需要遵守：

1. 只能是字母、数字、下划线、$，且不能数字开头
2. 字母区分大小写，如 Age 和 age 是不同的变量
3. JavaScript 内部已占用于单词（关键字或保留字）不允许使用
4. 尽量保证变量具有一定的语义，见字知义，使用小驼峰命名法。

注：关键字是指 JavaScript 内部使用的词语，如 `let` 和`var`，保留字是指 JavaScript 内部目前没有使用的词语，但是将来可能会使用词语。

```js
    let age = 18 // 正确
    let age1 = 18 // 正确
    let _age = 18 // 正确

    // let 1age = 18; // 错误，不可以数字开头
    let $age = 18 // 正确
    let Age = 24 // 正确，它与小写的 age 是不同的变量
    // let let = 18; // 错误，let 是关键字
    let int = 123 // 不推荐，int 是保留字
```

### 5.4 常量

概念：使用 const 声明的变量称为“常量”。

使用场景：当某个变量永远不会改变的时候，就可以使用 const 来声明，而不是let。

命名规范：和变量一致

常量名一般都全部使用大写字母，多个单词用下划线连接。

~~~js
// 常量是不会改变的变量，用const声明，命名规则与变量差不多。
	const PI= 3.1415926;
	console.log(PI);
~~~

**注意： 常量不允许重新赋值,声明的时候必须赋值（初始化）**

## 六、基本数据类型

> 计算机世界中的万事成物都是数据。

计算机程序可以处理大量的数据，为了方便数据的管理，将数据分成了不同的类型：基本数据类型和引用（复杂）数据类型。

基本数据类型：数值型number、字符串型string、布尔类型boolean、未定义型undefined、空类型null。

引用数据类型：对象型object。

注：通过 typeof 关键字检测数据类型

**注：JavaScript 中变量的值决定了变量的数据类型。**

### 6.1 数值类型number

```js
// js中的整数、小数统称数字型
	let num1 = 10;
	let num2 = 20.5;
	let num3 = -10;
	let num4 = 9/0; // NaN 不是一个数字，但这个归属于NaN。任何值与NaN进程操作都是NaN。
	console.log(num1, num2, num3,num4);
```

JavaScript 中的数值类型与数学中的数字是一样的，分为正数、负数、小数等。JS与其他编程语言不同，整数小数统称数值。

数值经常和算数运算符一起搭配使用。

算数运算符：`加+、减-、乘*、除/、取模%`，优先级和数学中一样。

### 6.2 字符串类型string

通过单引号（ `''`） 、双引号（ `""`）或反引号（`）【模板字符串】包裹的数据都叫字符串，单引号和双引号没有本质上的区别，推荐使用单引号。

注意事项：

1. 无论单引号或是双引号必须成对使用
2. 单引号/双引号可以互相嵌套，但是不以自已嵌套自已
3. 必要时可以使用转义符 `\`，输出单引号或双引号

```js
let userName = '小明' // 使用单引号
	let gender = "男" // 使用双引号
	let str = '123' // 看上去是数字，但是用引号包裹了就成了字符串了
	let str1 = '' // 这种情况叫空字符串
	let str2 = `这也是字符串`;
	console.log(userName);
	console.log(gender);
	console.log(str);
	console.log(str1);
	console.log(str2);
```

加号在字符串中作用是拼接字符串。

```javascript
let qiYu = '琦玉';
	console.log(qiYu + '老师');
	let teacher = '老师';
	console.log(qiYu + teacher);
	let age = 24;
	console.log('我今年' + age + '岁');
```

模板字符串：字符串拼接变量比较麻烦，而模板字符串可以直接连接字符串和变量。

```js
let age = 24;
	// 模板字符串用反引号包裹，${变量名}，模板字符串就是用来拼接字符串的。
	console.log(`我今年${age}岁`);
```

### 6.3 布尔类型boolean

表示肯定或否定时在计算机中对应的是布尔类型数据，它有两个固定的值 `true` 和 `false`，表示肯定的数据用 `true`，表示否定的数据用 `false`。

```js
let isCool = true;
    isCool = false;
```

### 6.4 未定义类型undefined

未定义是比较特殊的类型，只有一个值 undefined，只声明变量，不赋值的情况下，变量的默认值为 undefined。开发中基本不会【直接】为某个变量赋值为 undefined。

```js
// undefined类型只有一个值就是undefined。
	// 一般不会显示声明变量的值是undefined，变量定义了没有赋值就是undefined。
	let age;
	console.log(age); // => undefined
```

这个类型在函数中使用，用来判断变量的值是否接收到。

### 6.5 空类型null

空类型也只有一个值就是null，表示空的。

**要注意的是null使用typeof判断类型时结果为object。**

null和undefined的区别：

- null是变量已经有值，只是内容为空
- undefined表示变量没有赋值

在官方解释中，null表示对象，只是对象没有创建。

### 6.6 数据类型检测

可以使用typeof检测数据类型。

typeof是一个运算符，有两种语法形式：

- 作为运算符：`typeof x`这种方式很常用。
- 函数形式：typeof()

这两种方式得到的结果都是一样的，一般直接把typeof当成运算符使用

```js
	let num = 10;
	console.log(typeof num); // => number
	let str1 = '10';
	console.log(typeof str1); // => string
	let flag = false;
	console.log(typeof flag); // => boolean
	let nu;
	console.log(typeof nu); // => undefined
	let obj = null;
	console.log(typeof obj); // => object
```

## 七、类型转换

> 理解弱类型语言的特征，掌握显式类型转换的方法

在 JavaScript 中数据被分成了不同的类型，如数值、字符串、布尔值、undefined，在实际编程的过程中，不同数据类型之间存在着转换的关系。

JS是弱数据类型，只有赋值后才知道明确的数据类型。

在使用表单、prompt等方式获取到的数据默认都是字符串类型的，如果直接进行加法运算，可能会出现问题。这时候需要进行数据类型转换。

数据类型转换通俗讲就是**将一种数据类型的变量转换成需要的数据类型**。

### 7.1 隐式转换

某些运算符被执行时，系统内部自动将数据类型进行转换，这种转换称为隐式转换。

规则：

- +号两边只要有一个是字符串，都会把另一个转为字符串。
- 除了+号以外的算数运算符都会把数据转成数字类型。

这种隐式转换类型不明确，可能会产生想不到的问题。

技巧：

- +号作为正号解析可以转为数字型
- 任何数据和字符串相加结果都是字符串

```js
	let num = 13;// 数值
	let num2 = '2'; // 字符串
	// 结果为 132
	// 原因是将数值 num 转换成了字符串，相当于 '13'
	// 然后 + 将两个字符串拼接到了一起
	console.log(num + num2); // => '132'

	// 结果为 11
	// 原因是将字符串 num2 转换成了数值，相当于 2
	// 然后数值 13 减去 数值 2
	console.log(num - num2); // => 11
	console.log(num * num2); // => 26

	let a = +prompt('请输入一个数字');
	let b = +prompt('请再输入一个数字');
	console.log(typeof a, typeof b);  // => number
	console.log(a + b); 
```

注：数据类型的隐式转换是 JavaScript 的特征

### 7.2 显式转换

编写程序时过度依靠系统内部的隐式转换是不严禁的，因为隐式转换规律并不清晰，大多是靠经验总结的规律。为了避免因隐式转换带来的问题，通常根逻辑需要对数据进行显示转换。

在实际开发中，一般只会进行数字和字符串类型的转换，其他的类型很少。

#### 7.2.1 转为数值

通过 `Number()` 显示转换成数值类型，当转换失败时结果为 `NaN`（Not a Number）即不是一个数字。

```js
	let t = '12';
	let f = 8;

	// 显式将字符串 12 转换成数值 12
	t = Number(t);

	// 检测转换后的类型
	console.log(typeof t); // => number
	console.log(t + f); // => 20

	// 并不是所有的值都可以被转成数值类型
	let str = 'hello';
	// 将 hello 转成数值是不现实的，当无法转换成
	// 数值时，得到的结果为 NaN （Not a Number）
	console.log(Number(str)); // => NaN
```

`parseInt()、parseFloat()`只传入一个字符串参数，可以进行字符串转数值。

parseInt只保留整数，parseFloat会保留小数。

```js
console.log(parseInt('12px')); // => 12
console.log(parseInt('12.5px')); // => 12
console.log(parseFloat('12.5px')); // => 12.5
console.log(parseFloat('12.6px')); // => 12.6
```

#### 7.2.2 转为字符串

通过 `String()`和`变量.toString()`显示转换成字符类型。

这使用的并不是很多。

#### 7.2.3 转为布尔值

`Boolean()`

除了‘’、0、undefined、null、false、NaN转为布尔值都是false，其余都是true

## 八、常用运算符

### 8.1 算数运算符

算数运算符和数学中的差不多，只是要注意模运算（%），在数学中叫取余数。

算数运算符的运算规则和数学中一样。

### 8.2 赋值运算符

赋值运算符：对变量进行赋值的运算符。

将=右边的值赋与给左边，要求左边必须是一个变量。

基础赋值运算符`=`，可以与算数运算符搭配使用，简化代码书写。

如：

```js
let num = 10;
let sum=0;
sum += num; // sum = sum + num；效果一样
```

除了`+=`还有`-=、*=、/=、%=`。

### 8.3 一元运算符

JS的运算符可以根据所需表达式的个数分为一元运算符、二元运算符、三元运算符。

一元运算符：++ -- 、正号、负号。

二元运算符：算数运算符、逻辑运算符等都是二元。

三元运算符：?:

++是自增，让变量的值+1

--是自减，让变量的值-1

自增自减运算符经常用于计数，如进行10次操作，用它来计算进行了多少次。

前置自增和后置自增单独使用没有区别。

前置自增和后置自增参与运算则有区别：

- 前置：先自增，再参与运算
- 后置：先运算，后自增

```js
	let num = 10;
	// ++自增
	++num;  // 前置自增
	console.log(num);

	let num2 = 20;
	num2++; // 后置自增
	console.log(num2);

	let m = 1;
	// ++在前，先自增，再参与运算
	console.log(++m + 1); // 3
	console.log(m); // 2
	let n = 1;
	// ++在后，先运算，再自增
	console.log(n++ + 1); // 2
	console.log(n) // 2
```

**在开发中，一般会单独使用后置自增。**

自减的规则一样。

### 8.4 比较运算符

比较运算符是比较两个数据大小、是否相等。

比较运算符：`> < >= <= == === != !==`

注意：`==`是左右两边值是否相等，`===`左右两边是否类型和值都相等。

比较运算符的结果是布尔类型。

**不同数据类型之间比较有隐式转换**。

```js
  console.log(3 > 5);
	console.log(3 >= 3);
	console.log(2 == 2);
	console.log(2 == '2');
	console.log(2 === '2');
	console.log(1 !== 2);
	console.log(NaN === NaN); // NaN不等于任何值，包括本身
```

开发中，使用`===和!==`，不要使用==和!=。

注意：字符串的比较通过ASCII码值比较的，从左到右依次比较，第一位相等则比较第二位，依此类推。

```js
console.log('abc' > 'acb');
```

**尽量不要比较小数，有精度问题**。

### 8.5 逻辑运算符

逻辑运算符用来解决多出条件判断。

| 符号 | 名称   | 日常读法 | 特点                              | 口诀           |
| :--: | ------ | :------: | --------------------------------- | -------------- |
|  &&  | 逻辑与 |   并且   | 符号两边都为true，结果才为true    | 一假则假       |
| \|\| | 逻辑或 |   或者   | 符号两边只要有一个tue，结果为true | 一真为真       |
|  !   | 逻辑非 |   取反   | true变为false，false变为true      | 真是假，加为真 |

```js
	console.log(true && false);
	console.log(false && true);
	console.log(3 < 5 && 3 > 2);


	console.log(true || true);
	console.log(true || false);
	console.log(false || false);

	
	console.log(!true);
	console.log(!false);
```

逻辑运算符中的&&和||有短路现象，当满足一定条件会让右边代码不执行。

&&：左边为false就短路

||：左边为true就短路

```js
	function fn(x, y) {
		x = x || 0;
		y = y || 0;
		console.log(x + y);
	}

	fn();

	let age = 18;
	console.log(false && age++); // &&左边为假，age++不执行
	console.log(11 && 22); // &&左右都为真，返回最后一个真值
	console.log(11 || age++); // ||左边为真，age++ 也不执行，返回第一个真值.两个都是假，返回最后一个假值
	console.log(age);
```

### 8.6 运算符优先级

按照从高到低的顺序，依次是：

小括号、一元、算数、【关系（大于、小于、大于等于、小于等于）】、相等、逻辑（先&&后||）、赋值、逗号

## 九、常用语句

### 9.1 表达式和语句

表达式：可以被求值的代码，JS引擎会将其计算出一个结果

语句：一段可以执行的代码

区别：

- 表达式可以被求值，可以写在赋值语句的右侧
- 语句不一定有值

在某些情况下，可以把表达式理解为表达式语句。

### 9.2 流程控制语句

程序中一般有三大流程控制语句。

顺序结构：从上到下执行语句。

分支结构：根据条件选择执行代码。

循环结构：某段代码被重复执行。

三大结构不是单独存在的，而是组合在一起。

### 9.3 分支语句

#### 9.3.1 if语句

##### 1、单分支if语句

```
if (条件){
	满足条件要执行的代码
}
```

条件为true，执行大括号中的代码。

如果条件的结果不是布尔类型，会发生隐式转换为布尔类型（除了0，所有数字都是true；除了空字符串，所有字符串都是true）。

大括号只有一条语句，可以省略大括号，但不推荐。

##### 2、双分支if语句

```
if (条件) {
	满足条件要执行的代码
} else {
	不满足条件执行的代码
}
```

```js
	let uname = prompt('请输入用户名：');
	let pwd = prompt('请输入密码：');
	if (uname === 'tom' && pwd === '123456') {
		alert('登录成功');
	} else {
		alert('用户名或密码错误');
	}
```

##### 3、多分支if语句

```
if(条件1){
	代码1
} else if(条件2){
	代码2
} else if(条件3){
	代码3
} else {
		代码n
}
```

多分支if语句适合有多个结果的时候。

执行过程：

1、先判断条件1，满足则执行代码1，其他的都不执行；

2、不满条件1，则判断条件2，满足则执行代码2，其他的都不执行；

3、依次类推，所有条件都不满足，则执行else中的代码。

多分支if语句可以写很多else if，但只有一个if和else。

```js
	let score = +prompt('请输入有效成绩：');
	if (score >= 90) {
		alert('优秀');
	} else if (score >= 70) {
		alert('良好');
	} else if (score >= 60) {
		alert('及格');
	} else {
		alert('不及格');
	}
```

#### 9.3.2 三元表达式

使用场景：简单双分支if可以使用。

符号：？：

语法：

```
条件 ? 满足条件执行的代码 : 不满足条件执行的代码
```

三元运算符一般用来取值。

```js
	let num1 = +prompt('请输入第一个数：');
	let num2 = +prompt('请输入第二个数：');
	let max = num1 > num2 ? num1 : num2;
	console.log(`最大值是${max}`);
```

#### 9.3.3 switch语句

```
switch (数据) {
	case 值1:
			代码1;
			break;
	case 值2:
			代码1;
			break;
	default:
			代码n;
}
```

执行过程：

1. 找到跟小括号里数据**全等**的case值，并执行里面对应的代码
2. 没有全等的值则执行default中的代码

switch语句一般用于等值判断，不适合区间判断。

switch语句一般要配合break语句使用，没有break关键字会造成case穿透。

```js
	let num1 = +prompt('请输入操作数1：');
	let num2 = +prompt('请输入操作数2：');
	let op = prompt('请输入四则运算符中的一个：');
	switch (op) {
		case '+':
			document.write(`两个操作的的加法操作：${num1 + num2}`);
			break;
		case '-':
			document.write(`两个操作的的减法操作：${num1 - num2}`);
			break;
		case '*':
			document.write(`两个操作的的乘法操作：${num1 * num2}`);
			break;
		case '/':
			document.write(`两个操作的的除法操作：${num1 / num2}`);
			break;
		default:
			document.write('请输入正确的的四则运算符');
	}
```

#### 9.3.4 if多分支语句与switch的区分

共同点：

1. 都能实现多分支选择
2. 大部分情况下能互换

区别：

1. switch语句通常处理case为比较**确定值**的情况，if语句更灵活，通常适应于范围判断。
2. switch语句进行判断后直接执行到程序的语句，效率更高，if语句有多种判断条件，需要多次判断。
3. switch必须使用全等，要注意数据类型，还需要注意break，否则有穿透效果。

结论：

- 分支较少，if执行效率更高
- 分支较多，switch结构更清晰，效率更高

### 9.4 循环语句

循环就是重复执行一些操作，开发中常用的循环有while循环和for循环。

循环的本质就是以某个变量为起始值，然后不断产生变化量，慢慢靠近终止条件的过程。

#### 9.4.1 while循环

while：在……期间。

while循环就是在满足条件期间重复执行某些代码。

```
while(循环条件){
	循环体
}
```

执行过程：

只有小括号中的循环条件为true时，循环体才会执行。

while大括号中的代码执行完毕后不会跳出，而是继续回到小括号里判断条件，然后执行循环体。直到循环条件不满足才会跳出循环。

循环三要素：

1. 变量起始值
2. 终止条件（没有终止条件循环会一直执行，造成死循环）
3. 变量变化量（自增或自减）

```js
	let i = 1;
	while (i <= 10) {
		console.log(i);
		i++;
	}
	
	let end = +prompt('请输入循环次数：');
	let n = 0;
	while (n < end) {
		console.log(n);
		n++;
  }

```

#### 9.4.2 跳出循环

可以使用continue和break语句跳出循环。

break，跳出所在的循环，循环不在执行。

continue跳出本次循环，不影响下一轮循环的执行。

```js
	let i = 1;
	while (i <= 10) {
		// console.log(i); // 1 2 3 4 5
		if (i === 5) {
			// break; // 退出当前整个循环
			i++
			continue; // 跳出本次循环，进行下一次
		}
		console.log(i); // 1 2 3 4 6 7 8 9 10
		i++;
	}
```

#### 9.4.3 基本for循环

for循环与while循环的区别只是语法差别。

```
for (变量起始值;终止条件;变量变化量){
	 要重复执行的代码
}
```

```js
for (let i = 0; i < 10; i++) {
		document.write(`i的值:${i}<br>`);
	}
```

**for循环常用于遍历数组。**

```js
	const arr = ['苏白', '苏谦', '白灿灿', '白瑾'];
	for (let i = 0; i <= arr.length - 1; i++) {
		document.write(arr[i]);
	}
```

退出循环

```js
	for (let i = 0; i <= arr.length - 1; i++) {
		if (arr[i] === '白灿灿') {
			// continue; // 退出本次循环，continue后的语句不在执行
			break; // 结束循环
		}
		console.log(arr[i]);
	}
```

当如果明确了循环的次数的时候推荐使用`for`循环,当不明确循环的次数的时候推荐使用`while`循环

#### 9.4.5 循环嵌套

循环中又嵌套了另一个循环。

一般是for循环嵌套，也大多只嵌套两层，所以嵌套循环也习惯叫双层for循环。

```
for (外部变量起始值;终止条件;变量变化量){
	 for (内部变量起始值;终止条件;变量变化量){
		循环体
	}
}
```

执行过程：外部循环执行1次，内部循环要全部执行。

```js
for (let i = 1; i <= 3; i++) {
		document.write(`第${i}天<br>`);
		for (let j = 1; j <= 5; j++) {
			document.write(`记住第${j}个单词<br>`);
		}
	}
```

<img src="https://cdn.jsdelivr.net/gh/yuhuo2022/pic-bed/web/pic202204261539339.png" alt="image-20220426153914271" style="zoom:25%;" />

## 十、数组

**数组：**(Array)是一种可以按顺序保存数据的数据类型

**使用场景：**如果有多个数据可以用数组保存起来，然后放到一个变量中，管理非常方便

### 10.1 数组的定义与基本使用

数组定义：

1. 通过 `[]` 定义数组，数组中存放真正的数据，如小明、小刚、小红等这些都是数组中的数据，这些数据称为数组元素，数组元素之间使用英文逗号分隔。

2. 除了通过字面量方式定义数组，也可以使用数组构造函数定义数组。

```js
	// 声明数组
	let names = ['苏白', '白灿灿', '白谨', '白棠'];
	let arr = Array(1, 2, 3, 4);
	
	console.log(names); // => ['苏白', '白灿灿', '白谨', '白棠']
	console.log(arr); // => [1, 2, 3, 4]

```

数组访问和索引：

数组中的每一个元素都有编号（索引），通过数组中的索引可以轻松访问到数组中的元素。

数组中的索引值，也称其为下标。

索引值实际是按着数据元素在数组中的位置依次排列的，注意是从` 0`开始。

语法：`数组名[下标]`

```js
	// 使用数组  数组下标从0开始
	console.log(names[0]); // => 苏白
	console.log(arr[0]); // => 1
```

数组元素类型：

数组做为数据的集合，它的元素值可以是任意数据类型。

一个数组的元素甚至可以是混合类型的，如：`arr['html',1000,[1,3,5],true]`。

数组的长度：

通过`数组.length`可以获取到数组的长度。

注意：数组是JS的一种数据类型，但归属于对象类型，是一种特殊的对象。

### 10.2 数组的基本操作

#### 10.2.1 数组遍历

```js
const arr = ['苏白', '苏谦', '白灿灿', '白瑾'];
	for (let i = 0; i <= arr.length - 1; i++) {
		console.log(arr[i]);
	}
```

#### 10.2.2 数组元素修改

语法：`数组[下标]=新值`

```js
const arr = ['苏白', '苏谦', '白灿灿', '白瑾'];
	arr[3] = '苏武';
	console.log(arr[3]);
	for (let i = 0; i < arr.length; i++) {
		arr[i] = arr[i] + '老师';
		console.log(arr[i]);
	}
```

#### 10.2.3 数组元素的添加与删除

数组提供了5个方法对元素进行添加与删除：

1. **push** 动态向数组的尾部添加一个元素，返回数组的长度
2. unshit 动态向数组头部添加一个元素，返回数组长度
3. pop 删除最后一个元素，返回删除的元素
4. shift 删除第一个元素，返回删除的元素
5. splice(起始位置，删除的个数) 动态删除任意元素，返回删除的元素组成的数组。不写参数2默认删除到最后

使用以上5个方法时，都是直接在原数组上进行操作，即成功调任何一个方法，原数组都跟着发生相应的改变。并且在添加或删除元素时 `length` 并不会发生错乱。

```js
	const arr = [1, 2, 3];

	// push:在数组末尾添加元素,返回数组长度
	arr.push(4);
	console.log(arr.push(5, 6)); // => 6
	console.log(arr); // => [1, 2, 3, 4,5,6]

	// unshift:在数组开头添加元素，返回数组长度
	console.log(arr.unshift(0)); // 7
	console.log(arr); // => [0,1, 2, 3, 4,5,6]

	// pop：删除数组最后一个元素，返回删除的元素
	console.log(arr.pop()); // => 6
	console.log(arr); // => [0,1, 2, 3, 4,5]

	// shift:删除第一个元素，返回删除的元素
	console.log(arr.shift()); // 0
	console.log(arr); // => [1, 2, 3, 4,5]

	// splice(起始位置-索引号，删除几个元素)：删除指定元素。不写第二个删除，默认删到最后。返回删除的元素组成的数组
	console.log(arr.splice(1,1)); // => [2]
	console.log(arr); // => [1, 3, 4, 5]
```

#### 10.2.4 数组排序

对数组元素进行排序可以使用sort方法。

语法：`数组.sort()`，不写参数默认升序。

```js
	const arr = [4, 5, 2, 3, 1];
	// 默认升序
	// console.log(arr.sort()); // => [1, 2, 3, 4, 5]

	// 升序写法
	arr.sort(function (a, b) {
		return a - b;
	});
	console.log(arr);

	// 降序写法
	arr.sort(function (a, b) {
		return b - a;
	});
	console.log(arr); // => [5, 4, 3, 2, 1]
```

## 十一、函数

函数可以把具有相同或相似逻辑的代码“包裹”起来，通过函数调用执行这些被“包裹”的代码逻辑，这么做的优势是有利于精简代码方便复用。

### 11.1 函数的定义与调用

一个完整函数包括关键字、函数名、形式参数、函数体、返回值5个部分。

<img src="https://cdn.jsdelivr.net/gh/yuhuo2022/pic-bed/web/pic202204130146272.jpg" alt="function" style="zoom:50%;" />

声明（定义）的函数必须调用才会真正被执行，使用 `函数名()` 调用函数。

注：函数名的命名规则与变量是基本一致的，并且尽量保证函数名的语义。

函数不调用不会执行，一个函数可以重复调用。

```js
	// 函数定义
	function sayHi() {
		console.log('嗨');
	}

	// 函数调用
	sayHi();
	sayHi();
	sayHi();
```

### 11.2 函数参数

通过向函数传递参数，可以让函数更加灵活多变，参数可以理解成是一个变量。

```
function 函数名(参数列表){
	函数体
}
函数名(传递的参数列表)
```

参数列表：声明函数需要传入的数据个数。

声明（定义）函数时的形参没有数量限制，当有多个形参时使用 `,` 分隔。

调用函数传递的实参要与形参的顺序一致。

形参和实参：

形参：声明函数时写在函数名右边小括号里的叫形参（形式上的参数）。

实参：调用函数时写在函数名右边小括号里的叫实参（实际上的参数）。

形参可以理解为是在这个函数内声明的变量，实参可以理解为是给这个变量赋值。

开发中尽量保持形参和实参个数一致。

实参不一定是字面量，可以是变量。

形参默认值：

函数有形参，但调用时没有传入实参，会出现问题。

为了让程序更加严谨，可以给形参设置默认值，当函数调用时没有传入实参就用默认形参值。

形参默认值只会在缺少实参时才会使用，有实参会优先使用实参

```js
	/**
	 * 求两个数之间的累加和
	 * @param start  默认值0
	 * @param end  默认值0
	 */
	// 函数定义时的参数是形式上的参数（形参）
	function getSum(start = 0, end = 0) {
		let sum = 0;
		for (let i = start; i <= end; i++) {
			sum += i;
		}
		console.log(sum);
	}

	getSum(50, 100); // 函数调用传入的是实际参数（实参）
	
	getSum(); // 没有传入实参，使用形参默认值
	
	let start = +prompt('请输入起始值：');
	let end = +prompt('请输入结束值：');
	getSum(start, end); // 实参可以是变量
```

### 11.3 函数返回值

函数的本质是封装，函数体内的逻辑执行完毕后，函数外部要想获得函数内部逻辑的执行结果，需要通过 `return` 这个关键字，将内部执行结果传递到函数外部，这个被传递到外部的结果就是返回值。

```
return 数据;
```

函数内部只能出现1次 return，并且return下一行代码不会再被执行，所以return 后面的数据不要换行写。

return会立即结束当前函数。

函数可以没有return，这种情况默认返回值为undefined。

```js
	function getSum(num1, num2) {
		// return 不能换行写，return后的代码不会执行
		// 函数不写return，默认返回undefined
		return num1 + num2;
	}

	let result = getSum(1, 2);
	console.log(result);
```

### 11.4 函数的一些细节

在非严格模式下，两个相同的函数后面的会覆盖前面的函数。

在JS中，实参的个数和形参的个数可以不一致：

- 形参个数多于实参，自动填上undefined
- 实参个性多于形参，多余的实参会被忽略（函数内部有一个arguments里面装着所以的实参）

### 11.5 作用域

通常来说，一段程序代码中所用到的名字并不总是有效和可用的，而限定这个名字的可用性的代码范围就是这个名字的作用域。

作用域的使用提高了程序逻辑的局部性，增强了程序的可靠性，减少了名字冲突。

全局作用域：

作用于所有代码执行的环境(整个script标签内部)或者一个独立的js文件。

处于全局作用域内的变量，称为全局变量。

局部作用域：

作用于函数内的代码环境，就是局部作用域。 因为跟函数有关系，所以也称为函数作用域。

处于局部作用域内的变量称为局部变量。

如果函数内部，变量没有声明，直接赋值，也当全局变量看，但是强烈不推荐这样做。但函数内部的形参可以看做是局部变量。

```js
	let num = 10; // 全局变量
	console.log(num); // => 10
	
	
	number = 20; // 没有声明直接使用，全局变量，不建议使用
	function fn() {
		console.log(number); // => 20
		console.log(num); // => 10
	}
	fn();
	console.log(number); // => 20
	
	// 形参可以看成是函数的局部变量
	function fun(x, y) {
		let str = 'string';
		console.log(str); // => string
		console.log(x, y); // => 1,2
	}

	fun(1, 2);

	console.log(x, y); // 报错，没有定义
	console.log(str); // Uncaught ReferenceError: str is not defined
```

变量的访问原则：

- 变量至少有一个作用域
- 写在函数内部是局部作用域
- 函数中还有函数，作用域中又会诞生一个作用域
- 在作用域范围内，先局部，局部没有再往上一个作用域找，直到全局作用域（这个过程是作用域链）

### 11.6 匿名函数

函数可以分为具名函数和匿名函数

匿名函数：没有名字的函数，无法直接使用。

可以通过函数表达式或者立即执行函数来使用函数表达式。

**函数表达式**：将匿名函数赋值给一个变量，并通过变量名进行调用。

函数表达式与具名函数的区别：

- 具名函数的调用可以写到任意位置；
- 函数表达式必须先声明函数表达式，然后才能调用。

**立即执行函数**：`(function (){})();`或者`(function () {}());`。立即执行函数可以防止全局变量污染。

函数写完直接调用，不需要手动去调用。

**多个立即执行函数一定要分号分隔，否则会报错。**

```js
	// 函数表达式
	let fn = function (x, y) {
		console.log('函数表达式');
		return x + y;
	}
	console.log(fn);
	fn(1, 2);

	// 立即执行函数
	(function () {
		let num = 1;
		console.log(num);
	})();
	
	(function (x, y) {
		let num = 2;
		console.log(num);
		return x + y;
	})(1, 2);

	// 立即执行函数的另一种写法
	(function () {
		console.log('这也是立即执行函数');
	}());
```

立即执行函数也可以是具名函数。

## 十二、对象

对象（object）是JavaScript数据类型的一种，可以理解为一种无序的数据集合，它由属性和方法两部分构成。

### 12.1 对象声明

创建对象的方式有很多种，常用的是通过字面量创建或者构造函数创建。

```
let 对象名 = {
	属性名：属性值，
	方法名：函数
};
let 对象名 = new Object();
```

属性是事物的特征，如颜色、尺寸等。通常是名词。

方法是事物的行为，如吃、玩等。通常是动词。

属性和方法都是以键值对的方式出现，键与值之间用`:`分隔。

多个属性和方法之间用`,	`分隔。

属性就是依附在对象上的变量（常量）。

属性名可以使用引号包裹，一般情况下省略不写，除非属性名中包含特殊符号。

属性名和属性值相同，可以简写，只写属性名。

方法也可以简写，省略冒号和function关键字。

方法本质是函数，调用方式`对象名.方法名()`或者`对象名['方法名']()`

**注：无论是属性或是方法，同一个对象中出现名称一样的，后面的会覆盖前面的。**

```js
	// 声明对象
	let age = prompt('请输入年龄');
	let obj = {
		uname: '苏白',
		// age: age,
		// 属性名与属性值一样，可以简写
		age,
		gender: '男',
		eat: function () {
			console.log('吃饭');
		},
		// 方法简写:省略冒号和function关键字
		sayHi() {
			console.log('嗨');
		}
	}
	console.log(obj);
```

### 12.2 对象的使用

对象作为数据集合，使用无非就是增删改查。

查询对象也叫属性访问，可以使用 `对象名.属性` 或 `对象名['属性']` 获得对象中属性对应的值。

修改对象是对属性进行重新赋值，`对象名.属性=值`。（对象中没有该属性相当于添加新属性）

对象添加新数据：`对象名.属性名=新值`。

删除对象属性：`delete 对象名.属性名`。(了解)

```js
	let obj = {
		uname: '苏白',
		age: 24,
		gender: '男'
	}

	// 获取属性值
	console.log(obj.uname); // => 苏白
	console.log(obj['age']); // => 24

	// 修改属性值
	obj.age = 25;
	console.log(obj); // => {uname: '苏白', age: 25, gender: '男'}

	// 添加属性
	obj.hobby = '阅读';
	console.log(obj); // => {uname: '苏白', age: 25, gender: '男', hobby: '阅读'}

	// 删除属性，新语法和严格模式下不允许之间删
	delete obj.gender;
	console.log(obj); // => {uname: '苏白', age: 25, hobby: '阅读'}
```

### 12.3 遍历对象

对象中是无序的键值对，没有规律，没有下标，没有长度，不能直接通过for循环遍历。

遍历对象用`for in`

```
for(let k in obj){}
```

for in可以遍历数组，但k的类型是字符串，遍历数组可能出问题，实际工作中不会用来遍历数组。

for in遍历对象很合适。

**输出属性值要用obj[k]（不能用点语法，k是字符串）**。

```js
	let obj = {
		uname: '苏白',
		age: 24,
		gender: '男',
		eat: function () {
			console.log('吃饭');
		},
		sayHi() {
			console.log('嗨');
		}
	}
	for (let objKey in obj) {
		// objKey是属性名 
		// console.log(objKey); // => 'uname'...
		
		console.log(obj[objKey]);
	}
```

### 12.4 常用内置对象

内置对象是JS内部提供的对象，有很多的方法和属性，需要时只要调用就行。

JS内置对象很多，需要时可以查文档，常用的内置对象有document、Math、console、Date等。

#### 12.4.1 Math数学对象

Math内置对象提供了很多数学方法，比较常用的有：

- random:生成0-1之间的随机数(包含0不包括1) 
- ceil:向上取整
- floor:向下取整
- max:找最大数
- min:找最小数
- pow:幂运算
- abs:绝对值

```js
	console.log(Math.PI);

	// 向上取整
	console.log(Math.ceil(1.1)); // => 2

	// 向下取整
	console.log(Math.floor(1.9)); // => 1

	// 四舍五入绝对值更大的整数
	console.log(Math.round(1.1)); // => 1
	console.log(Math.round(1.5)); // => 2

	// 最大最小值
	console.log(Math.max(1, 2)); // => 2
	console.log(Math.min(1, 2)); // => 1
```

**随机数**

random:生成0-1之间的随机数(包含0不包括1)。

生成任意范围随机数：`Math.floor(Math.random() * (M - N + 1)) + N`

```js
	// random:生成0-1之间的随机数(包含0不包括1)
	console.log(Math.random());

	// 生成[0,10]之间的随机数
	console.log(Math.floor(Math.random() * (10 + 1)));

	// 生成[5,10]之间的随机数
	console.log(Math.floor(Math.random() * (5 + 1)) + 5);
	
	// 生成任意范围内的随机数
	function getRandom(m, n) {
		return Math.floor(Math.random() * (m - n + 1)) + n;
	}

	console.log(getRandom(100, 150));

```

## 十三、 基本数据类型和引用数据类型

简单类型又叫做基本数据类型或者值类型，复杂类型又叫做引用类型。

- 值类型:简单数据类型/基本数据类型，在存储时变量中存储的是值本身，因此叫做值类型 。

​		string ，number，boolean，undefined，null

- 引用类型:复杂数据类型，在存储时变量中存储的仅仅是地址(引用)，因此叫做引用数据类型。

​		通过 new 关键字创建的对象(系统对象、自定义对象)，如 Object、Array、Date等

### 13.1 堆和栈

堆栈空间分配区别:

1、栈(操作系统):由操作系统自动分配释放存放函数的参数值、局部变量的值等。其操作方式类似于数据结构中的栈;**简单数据类型存放到栈里面**。

2、堆(操作系统):存储复杂类型(对象)，一般由程序员分配释放，若程序员不释放，由垃圾回收机制回收。**引用数据类型存放到堆里面**

### 13.2 简单数据类型内存分配

值类型变量的数据直接存放在变量(栈空间)中

<img src="https://cdn.jsdelivr.net/gh/yuhuo2022/pic-bed/web/pic202204281810599.png" alt="image-20220428181014529" style="zoom:50%;" />

### 13.3 复杂数据类型内存分配

引用类型变量(栈空间)里存放的是地址，真正的对象实例存放在堆空间中

<img src="https://cdn.jsdelivr.net/gh/yuhuo2022/pic-bed/web/pic202204281812542.png" alt="image-20220428181204473" style="zoom:50%;" />
